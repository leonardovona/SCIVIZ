<!DOCTYPE html>
<meta charset="utf-8">

<head>
    <link rel="stylesheet" href="style.css">
</head>

<body>

    <!-- Load d3.js -->
    <script src="https://d3js.org/d3.v6.js"></script>

    <!-- Create an element where the map will take place -->
    <div id="map">
    </div>
    <div class="range">
        <input type="range" min="2000" max="2019" steps="1" value="2019" id="year_input" list="steplist">
        <datalist id="steplist">
            <option value="2000"></option>
            <option value="2001"></option>
            <option value="2002"></option>
            <option value="2003"></option>
            <option value="2004"></option>
            <option value="2005"></option>
            <option value="2006"></option>
            <option value="2007"></option>
            <option value="2008"></option>
            <option value="2009"></option>
            <option value="2010"></option>
            <option value="2011"></option>
            <option value="2012"></option>
            <option value="2013"></option>
            <option value="2014"></option>
            <option value="2015"></option>
            <option value="2016"></option>
            <option value="2017"></option>
            <option value="2018"></option>
            <option value="2019"></option>
        </datalist>
        <p>Year: <output id="year"></output></p>
    </div>
    <div id="stackedBarChart"></div>
    <button onclick="update_sb(TOC)">TOC</button>

    <script>
        const EU_members = ["AT", "BE", "BG", "CY", "CZ", "DE", "DK", "EE", "EL", "ES",
            "FI", "FR", "HR", "HU", "IE", "IT", "LT", "LU", "LV", "MT", "NL", "PL", "PT", "RO", "SE", "SI", "SK"]
        // The svg

        const value = document.querySelector("#year")
        const input = document.querySelector("#year_input")
        value.textContent = input.value
        input.addEventListener("input", (event) => {
            value.textContent = event.target.value
            handle_update(event.target.value)
        })

        const width_map = 600, height_map = 550
        var svg = d3.select("#map")
            .append("svg")
            .attr("width", width_map)
            .attr("height", height_map)

        var colorScale = d3.scaleThreshold()
            .domain([0.01, 1, 2, 4, 8, 16, 32])
            .range(d3.schemeBlues[7]);

        const data = new Map()
        // Create a function that takes a dataset as input and update the plot:

        // Map and projection
        var path = d3.geoPath();
        var projection = d3.geoMercator()
            .scale(420)
            .center([13, 55])
            .translate([width_map / 2, height_map / 2]);

        // Data and color scale


        var tooltip = d3.select("#map")
            .append("div")
            .style("opacity", 0)
            .attr("class", "tooltip")

        // Load external data and boot
        Promise.all([
            d3.json("./resources/europe.geojson"),
            d3.csv("./resources/wei.csv")]).then(function (loadData) {
                let topo = loadData[0]

                let wei = loadData[1]

                wei.forEach(function (d) {
                    data.set(d.ID, d)
                })

                let mouseOver = function (d) {
                    if (EU_members.includes(d.srcElement.__data__.properties.ID)) {
                        d3.selectAll(".Country")
                            .transition()
                            .duration(200)
                            .style("opacity", .5)
                            .style("stroke", "transparent")
                        d3.select(this)
                            .transition()
                            .duration(200)
                            .style("opacity", 1)
                            .style("stroke", "black")
                        tooltip
                            .transition()
                            .duration(300)
                            .style("opacity", 1)
                    }
                }

                let mouseMove = function (d) {
                    if (EU_members.includes(d.srcElement.__data__.properties.ID)) {
                        tooltip
                            .html(d.srcElement.__data__.properties.NAME + ": " + d.srcElement.__data__.total)
                            .style("left", (d.clientX + 20) + "px")
                            .style("top", (d.clientY) + "px")
                    }
                }

                let mouseLeave = function (d) {
                    if (EU_members.includes(d.srcElement.__data__.properties.ID)) {
                        d3.selectAll(".Country")
                            .transition()
                            .duration(200)
                            .style("opacity", 1)
                            .style("stroke", "transparent")
                        tooltip.transition().duration(300)
                            .style("opacity", 0)
                    }
                }

                // Draw the map
                svg.append("g")
                    .selectAll("path")
                    .data(topo.features)
                    .enter()
                    .append("path")
                    // draw each country
                    .attr("d", d3.geoPath()
                        .projection(projection)
                    )
                    .style("stroke", "transparent")
                    .attr("class", function (d) { return "Country" })
                    .style("opacity", 1)
                    .on("mouseover", mouseOver)
                    .on("mousemove", mouseMove)
                    .on("mouseleave", mouseLeave)

                handle_update("2019")


            })

        function handle_update(year) {
            d3.selectAll(".Country")
                .transition()
                .duration(1000)
                .attr("fill", function (d) {
                    country = data.get(d.properties.ID)
                    if (country !== undefined) {
                        d.total = country[year]
                    } else {
                        d.total = 0
                    }
                    return colorScale(d.total);
                })
        }


        //Stacked bar chart

        // set the dimensions and margins of the graph
        const margin_bc = { top: 10, right: 30, bottom: 20, left: 70 },
            width_bc = 600 - margin_bc.left - margin_bc.right,
            height_bc = 400 - margin_bc.top - margin_bc.bottom;

        // append the svg object to the body of the page
        const svg_bc = d3.select("#stackedBarChart")
            .append("svg")
            .attr("width", width_bc + margin_bc.left + margin_bc.right)
            .attr("height", height_bc + margin_bc.top + margin_bc.bottom)
            .append("g")
            .attr("transform", `translate(${margin_bc.left},${margin_bc.top})`);


        pollutants_data = []
        // Parse the Data
        d3.csv("./resources/2007_water_pollutants.csv").then(function (data) {
            pollutants_data = data

            pollutants_data.sort(function (b, a) {
                a_nitrogen = parseFloat(a.Nitrogen) || 0;
                a_phosphorus = parseFloat(a.Phosphorus) || 0;
                a_toc = parseFloat(a.TOC) || 0;
                a_heavymetals = parseFloat(a['Heavy metals (Cd, Hg, Ni, Pb)']) || 0;

                b_nitrogen = parseFloat(b.Nitrogen) || 0;
                b_phosphorus = parseFloat(b.Phosphorus) || 0;
                b_toc = parseFloat(b.TOC) || 0;
                b_heavymetals = parseFloat(b['Heavy metals (Cd, Hg, Ni, Pb)']) || 0;

                tot_a = a_nitrogen + a_phosphorus + a_toc + a_heavymetals;
                tot_b = b_nitrogen + b_phosphorus + b_toc + b_heavymetals;

                return tot_a - tot_b;
            });

            // List of subgroups = header of the csv files = soil condition here
            const subgroups = pollutants_data.columns.slice(1)

            // List of groups = species here = value of the first column called group -> I show them on the X axis
            const groups = pollutants_data.map(d => (d.countryName))

            // Add X axis
            const x = d3.scaleBand()
                .domain(groups)
                .range([0, width_bc])
                .padding([0.2])

            svg_bc.append("g")
                .attr("transform", `translate(0, ${height_bc})`)
                .call(d3.axisBottom(x).tickSizeOuter(0));

            // Add Y axis
            const y = d3.scaleLinear()
                .domain([0, 170000000])
                .range([height_bc, 0]);
            svg_bc.append("g")
                .call(d3.axisLeft(y));

            // color palette = one color per subgroup
            const color = d3.scaleOrdinal()
                .domain(subgroups)
                .range(['#e41a1c', '#377eb8', '#4daf4a', '#834aaf'])

            //stack the data? --> stack per subgroup
            const stackedData = d3.stack()
                .keys(subgroups)
                // .order(d3.stackOrderDescending)
                (pollutants_data)

            // console.log(stackedData)
            // Show the bars
            svg_bc.append("g")
                .selectAll("g")
                // Enter in the stack data = loop key per key = group per group
                .data(stackedData)
                .join("g")
                .attr("fill", d => color(d.key))
                .selectAll("rect")
                // enter a second time = loop subgroup per subgroup to add all rectangles
                .data(d => d)
                .join("rect")
                .attr("x", d => x(d.data.countryName))
                .attr("y", d => y(d[1]))
                .attr("height", d => y(d[0]) - y(d[1]))
                .attr("width", x.bandwidth())
        })

        function update_sb(pollutant="all") {
            pollutants_data.sort(function (b, a) {
                if(pollutant == "all") {
                    a_nitrogen = parseFloat(a.Nitrogen) || 0;
                    a_phosphorus = parseFloat(a.Phosphorus) || 0;
                    a_toc = parseFloat(a.TOC) || 0;
                    a_heavymetals = parseFloat(a['Heavy metals (Cd, Hg, Ni, Pb)']) || 0;

                    b_nitrogen = parseFloat(b.Nitrogen) || 0;
                    b_phosphorus = parseFloat(b.Phosphorus) || 0;
                    b_toc = parseFloat(b.TOC) || 0;
                    b_heavymetals = parseFloat(b['Heavy metals (Cd, Hg, Ni, Pb)']) || 0;

                    tot_a = a_nitrogen + a_phosphorus + a_toc + a_heavymetals;
                    tot_b = b_nitrogen + b_phosphorus + b_toc + b_heavymetals;

                    return tot_a - tot_b;
                }
            
                a_pollutant = parseFloat(a[pollutant]) || 0;
                b_pollutant = parseFloat(b[pollutant]) || 0;

                return a_pollutant - b_pollutant;
            });

            // List of groups = species here = value of the first column called group -> I show them on the X axis
            const groups = pollutants_data.map(d => (d.countryName))

            // Add X axis
            const x = d3.scaleBand()
                .domain(groups)
                .range([0, width_bc])
                .padding([0.2])

            svg_bc.append("g")
                .attr("transform", `translate(0, ${height_bc})`)
                .call(d3.axisBottom(x).tickSizeOuter(0));

            // Add Y axis
            const y = d3.scaleLinear()
                .domain([0, 170000000])
                .range([height_bc, 0]);
            svg_bc.append("g")
                .call(d3.axisLeft(y));

            // color palette = one color per subgroup
            const color = d3.scaleOrdinal()
                .domain(subgroups)
                .range(['#e41a1c', '#377eb8', '#4daf4a', '#834aaf'])

            //stack the data? --> stack per subgroup
            const stackedData = d3.stack()
                .keys(subgroups)
                // .order(d3.stackOrderDescending)
                (pollutants_data)

            // console.log(stackedData)
            // Show the bars
            svg_bc.append("g")
                .selectAll("g")
                // Enter in the stack data = loop key per key = group per group
                .data(stackedData)
                .join("g")
                .attr("fill", d => color(d.key))
                .selectAll("rect")
                // enter a second time = loop subgroup per subgroup to add all rectangles
                .data(d => d)
                .join("rect")
                .attr("x", d => x(d.data.countryName))
                .attr("y", d => y(d[1]))
                .attr("height", d => y(d[0]) - y(d[1]))
                .attr("width", x.bandwidth())
        }


    </script>

</body>